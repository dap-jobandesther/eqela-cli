
/*
 * This file is part of Eqela CLI
 * Copyright (c) 2018 Job and Esther Technologies Oy
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

class is ConsoleApplicationMain:

import capex.console
import capex.util
import capex.web

var api = new LiveService()
var exc = new ExecutionContext()

func getConfigFile as File:
	return Environment.getApplicationDataDirectory("eqela").entry("client.config")

func readConfig
{
	var cfgfile = getConfigFile()
	Log.debug(ctx, "Reading config file: `" .. cfgfile.getPath() .. "'")
	var cfg = SimpleConfigFile.readFileAsMap(cfgfile)
	if cfg {
		var sessionid = cfg.getString("sessionid")
		if sessionid:
			api.setSessionid(sessionid)
	}
}

func writeConfig
{
	var cfgfile = getConfigFile()
	cfgfile.getParent().createDirectoryRecursive()
	var map = new DynamicMap()
	var sid = api.getSessionid()
	if not sid:
		sid = ""
	map.set("sessionid", sid)
	Log.debug(ctx, "Writing config file: `" .. cfgfile.getPath() .. "'")
	if not SimpleConfigFile.forMap(map).write(cfgfile):
		Log.error(ctx, "Failed to write config: `" .. cfgfile.getPath() .. "': " .. cfgfile.getLastErrorDescription())
}

func usage
{
	ConsoleApplication.PRINT_HEADER(stdout, null)
	var info = UsageInfo.forCommand("eqela")
	info.addFlag("help", "Show help / usage")
	info.addFlag("version", "Show version")
	info.addFlag("debug", "Display debug messages")
	info.addFlag("force-update-packages", "Always install all packages even if already installed")
	info.addOption("repository", "url", "Add a package repository url")
	info.addOption("cachedir", "path", "Specify an alternative cache directory")
	info.addOption("P<vendor:name>", "directory", "Configure a static package path")
	info.addOption("api", "url", "Specify an alternative URL for Eqela Live service")
	info.addSection("Subcommands")
	info.addParameter("script", "Execute a local script")
	info.addParameter("run", "Run a single command or statement")
	info.addParameter("login", "Log in to an Eqela Live service")
	info.addParameter("logout", "Log out from an Eqela Live service")
	info.addParameter("live-profile", "Display current Eqela Live profile")
	info.addParameter("live-create", "Create a new project")
	info.addParameter("live-translate", "Translate a source code file")
	stdout.println(info.toString())
}

func executeLogin(args as vector<CommandLineArgument>) private as bool
{
	assert String.isEmpty(api.getSessionid()):
		Log.error(ctx, "Already logged in")
	var v = false
	print("username: ")
	var username = readLine()
	print("password: ")
	var password = readLineWithoutEcho()
	Log.status(ctx, "Initializing session..")
	api.login(username, password, func(status as bool) {
		Log.status(ctx, null)
		Log.debug(ctx, "Login status: `" .. String.asString(status) .. "'")
		if status {
			Log.info(ctx, "Successfully logged in.")
		}
		else {
			Log.error(ctx, "Error when logging in: `" .. String.asString(api.getLastError()) .. "'")
		}
	})
	writeConfig()
	return v
}

func executeLogout(args as vector<CommandLineArgument>) private as bool
{
	assert String.isNotEmpty(api.getSessionid()):
		Log.error(ctx, "No active session. Cannot log out.")
	Log.status(ctx, "Terminating session..")
	var v = true
	api.logout(func(success as bool) {
		Log.status(ctx, null)
		if success {
			Log.debug(ctx, "Logout complete, sessionid now " .. api.getSessionid())
		}
		else {
			Log.error(ctx, String.asString(api.getLastError()))
		}
		v = success
	})
	writeConfig()
	return true
}

func executeGetProfile(args as vector<CommandLineArgument>) private as bool
{
	api.getProfile(func(profile as LiveService.ProfileModel) {
		if not profile {
			Log.error(ctx, "Failed to get profile: " .. String.asString(api.getLastError()))
		}
		else {
			Log.info(ctx, JSONEncoder.encode(profile.toJsonObject()))
		}
	})
	return true
}

func executeScript(args as vector<CommandLineArgument>) private as bool
{
	var script as File
	var function as string
	var functionParams as vector<string>
	foreach arg in args {
		if script && function {
			if not functionParams:
				functionParams = new vector<string>
			functionParams += arg.arg
			continue
		}
		if arg.isParameter() {
			if script == null {
				script = File.forPath(arg.parameter)
				continue
			}
			if function == null {
				function = arg.parameter
				continue
			}
		}
		arg.reportAsUnsupported(ctx)
		return false
	}
	assert script:
		Log.error(ctx, "No script defined")
	Log.debug(ctx, "Reading script: `" .. script.getPath() .. "'")
	var code = assert ScriptReader.readFile(ctx, script):
		Log.error(ctx, "Failed to read script: `" .. script.getPath() .. "'")
	return exc.executeScript(code, function, functionParams)
}

func executeRun(args as vector<CommandLineArgument>) private as bool
{
	var cwd as File
	var package as string
	var command as string
	var arguments = new vector<string>
	foreach arg in args {
		if package == null {
			if arg.isOption("cwd") {
				cwd = File.forPath(arg.value)
				continue
			}
			package = arg.arg
			continue
		}
		if command == null {
			command = arg.arg
			continue
		}
		arguments += arg.arg
	}
	assert String.isNotEmpty(package):
		Log.error(ctx, "No package defined")
	assert String.isNotEmpty(command):
		Log.error(ctx, "No command defined")
	if not cwd:
		cwd = Environment.getCurrentDirectory()
	var pdesc = assert PackageDescription.forString(package):
		Log.error(ctx, "Invalid package description: `" .. package .. "'")
	var script = new Script()
	script.setExecutionDirectory(cwd)
	script.addToUses(pdesc)
	var ff = new ScriptFunction()
	ff.setName("execute")
	ff.setScript(script)
	var stmt = ScriptStatement.forCommand(pdesc.getVendor() .. ":" .. pdesc.getName(), command)
	stmt.setArguments(arguments)
	ff.addToStatements(stmt)
	script.addToFunctions(ff)
	return exc.executeScript(script, "execute", new vector<string>)
}

func executeInstall(args as vector<CommandLineArgument>) private as bool
{
	var force = false
	var installs = new vector<string>
	foreach arg in args {
		if arg.isFlag("force") || arg.isFlag("f") {
			force = true
		}
		else if arg.isParameter() {
			installs += arg.parameter
		}
		else {
			arg.reportAsUnsupported(ctx)
			return false
		}
	}
	foreach install in installs {
		try {
			exc.installPackage(PackageDescription.forString(install), force)
		}
		catch(e as Exception) {
			Log.error(ctx, String.asString(e))
			return false
		}
	}
	return true
}

func executeCommand(cmd as string, cmdArgs as vector<CommandLineArgument>) as bool
{
	if cmd == "script" || cmd == "qx":
		return executeScript(cmdArgs)
	if cmd == "install":
		return executeInstall(cmdArgs)
	if cmd == "run":
		return executeRun(cmdArgs)
	if cmd == "login":
		return executeLogin(cmdArgs)
	if cmd == "logout":
		return executeLogout(cmdArgs)
	if cmd == "live-profile":
		return executeGetProfile(cmdArgs)
	if cmd == "live-create":
		return new CreateApp().setApi(api).setCtx(ctx).executeWithParsedArguments(cmdArgs)
	if cmd == "live-translate":
		return new TranslateApp().setApi(api).setCtx(ctx).executeWithParsedArguments(cmdArgs)
	Log.error(ctx, "Unsupported command: `" .. cmd .. "'")
	return false
}

func execute override as bool
{
	handleVerbosityParams()
	readConfig()
	var webclient = NativeWebClient.instance()
	if not webclient:
		Log.warning(ctx, "No webclient available. Cannot perform any online actions.")
	exc.setCtx(ctx)
	exc.addToRepositories(PackageRepository.forUrl("http://qx.eqela.com", webclient))
	var command as string
	var commandArgs = new vector<CommandLineArgument>
	foreach arg in args {
		if command {
			commandArgs += arg
			continue
		}
		if arg.isFlag("help") || arg.isFlag("h") {
			usage()
			return true
		}
		else if arg.isFlag("version") || arg.isFlag("v") {
			PRINT VALUE "version"
			return true
		}
		else if arg.isFlag("force-update-packages") {
			exc.setForceUpdatePackages(true)
		}
		else if arg.isOption("repository") {
			exc.addToRepositories(PackageRepository.forUrl(arg.value, webclient))
		}
		else if arg.isOption("cachedir") {
			exc.setCacheDirectory(File.forPath(arg.value))
		}
		else if arg.isOption() && (String.startsWith(arg.key, "P") || String.startsWith(arg.key, "T") || String.startsWith(arg.key, "L")) {
			exc.addToCustomPackagePaths(String.getSubString(arg.key, 1), File.forPath(arg.value))
		}
		else if arg.isOption("api") {
			api.setApiUrl(arg.value)
		}
		else if arg.isParameter() {
			if String.endsWith(arg.parameter, ".qx") {
				command = "script"
				commandArgs += arg
			}
			else {
				command = arg.parameter
			}
		}
		else {
			arg.reportAsUnsupported(ctx)
			return false
		}
	}
	if String.isEmpty(command) {
		usage()
		return false
	}
	if ctx.isInDebugMode() {
		api.setDebugCallback(func(info as string) {
			Log.debug(ctx, "[API] " .. info)
		})
	}
	return executeCommand(command, commandArgs)
}

main:
	return executeMain(new this(), args)
